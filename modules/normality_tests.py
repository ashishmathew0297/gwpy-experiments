import math as _math
import pycbc as _pycbc
import numpy as _np
import warnings as _warnings
import pandas as _pd
from scipy import stats as _stats
import matplotlib.pyplot as _plt
from gwpy.timeseries import TimeSeries as _TimeSeries
from matplotlib.ticker import ScalarFormatter
from sklearn.preprocessing import MinMaxScaler as _MinMaxScaler

_warnings.filterwarnings('ignore')


def generate_sample_statistics(noise: _TimeSeries) -> list:
    '''
    This function uses the input glitch TimeSeries sample in pycbc form to calculate and return a list of the following

    - Shapiro-Wilks statistic
    - Shapiro-Wilks p-value
    - Kolmogorov-Smirnov statistic
    - Kolmogorov-Smirnov p-value
    - Anderson-Darling statistic
    - Anderson-Darling critical values
    - Anderson-Darling significance levels

    Inputs:
    - `glitch_timeseries`: TimeSeries object of the glitch

    Output:
    - **data_df**: a list containing the following
        - 'shapiro_statistic': Shapiro-Wilks statistic of the sample amplitudes
        - 'shapiro_pvalue': Shapiro-Wilks p-value of the sample amplitudes
        - 'ks_pvalue': Kolmogorov-Smirnov p-value of the sample amplitudes
        - 'ad_statistic': Anderson-Darling statistic
        - 'ad_critical_values': Critical values for the Anderson Darling statistic
        - 'ad_significance_level': Significance level for the Anderson Darling statistic
        - 'kurtosis': Kurtosis of the glitch amplitude values
        - 'skew': Skew of the glitch amplitude values
    '''

    np.random.seed(42)
    
    y = noise.value

    sw_statistic = _stats.shapiro(y)

    # The Kolmogorov Smirnov statistic needs to be applied to a scaled
    # version of our data to work properly since it is a distance-based
    # metric
    scaler = _MinMaxScaler(feature_range=(-4,4))
    ks_statistic = _stats.ks_2samp(list(scaler.fit_transform(y.reshape(-1,1))[:,0]), _stats.norm.rvs(size=len(y), random_state=_np.random.default_rng()))

    ad_statistic = _stats.anderson(y, dist='norm')
    kurtosis = _stats.kurtosis(y, fisher=False)
    skew = _stats.skew(y)

    return [
        sw_statistic.statistic,
        sw_statistic.pvalue,
        ks_statistic.statistic,
        ks_statistic.pvalue,
        ad_statistic.statistic,
        ad_statistic.critical_values,
        ad_statistic.significance_level,
        kurtosis,
        skew
        ]

def shapiro_pvalue_histogram(data_df: _pd.DataFrame) -> None:
    '''
    A function to plot a histogram of the shapiro p-values from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `data_df`: The whole, or a section of the input dataframe. Must contain ['shapiro_pvalue']

    Display:
    A histogram of the Shapiro test p-values for the glitch samples 
    '''
    _plt.hist(data_df['shapiro_pvalue'], bins=40)
    # _plt.xscale('log')
    _plt.xlabel('Shapiro p-value')
    _plt.ylabel('Frequency')
    _plt.xticks(list(_np.arange(data_df['shapiro_pvalue'].min(), data_df['shapiro_pvalue'].max()+0.01, 0.01)), fontsize=8, rotation=90)
    # _plt.xticks(_np.arange(0, 0.04*tw, 0.01), fontsize=8)
    # _plt.xticks(list(_plt.xticks()[0]) + [0.05])
    _plt.title('Histogram of Shapiro p-values')
    _plt.grid(True)
    _plt.show()
    print(f"Number of Shapiro p-values above 0.05: {(data_df['shapiro_pvalue'] > 0.05).sum()}")
    print(f"Max Shapiro p-value: {data_df['shapiro_pvalue'].max()}")
    print(f"Min Shapiro p-value: {data_df['shapiro_pvalue'].min()}")

def display_glitch_plots(data: _pd.DataFrame, glitch_index: int) -> None:
    '''
    A function to display a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `data`: A single row of the input dataframe. Must contain ['t', 'y', 'noise', 'q_transform'].

    Display:
    A plot of the whitened glitch, the unwhitened glitch, and the q-transform of the glitch
    '''
    fig, ax = _plt.subplots(1,3, figsize=(24, 6))
    ax[0].plot(data['t'].iloc[glitch_index], data['y'].iloc[glitch_index])
    ax[0].set_xlabel("Time (s)")
    ax[0].set_ylabel("Amplitude")
    ax[0].legend()

    ax[1].plot(data['t'].iloc[glitch_index],data["glitch_timeseries"].iloc[glitch_index])
    ax[2].set_xlabel("Time (s)")
    ax[1].set_ylabel("Amplitude")
    ax[1].legend()

    ax[2].imshow(data['q_scan'].iloc[glitch_index])
    ax[2].set_yscale('log', base=2)
    ax[2].set_xscale('linear')
    ax[2].set_ylabel('Frequency (Hz)')
    ax[2].set_xlabel('Time (s)')
    ax[2].images[0].set_clim(0, 25.5)
    fig.colorbar(ax[2].images[0], ax=ax[2], label='Normalized energy', orientation='vertical', fraction=0.046, pad=0.04)

    _plt.show()

def display_probability_plot(sample_glitch: _pd.DataFrame) -> None:
    '''
    A function to display the Q-Q/probability plot of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `sample_glitch`: A **single row** of the input dataframe. Must contain ['GPStime', 'y', 'shapiro_pvalue'].

    Display:
    A plot of the glitch sample timeseries with sections highlighted to show the  
    '''
    fig,ax = _plt.subplots(1,2, figsize=(12,5))
    _stats.probplot(sample_glitch["y"], dist="norm", plot=ax[0])
    ax[1].axis("off")
    ax[1].text(0.1, 0.5, f'Shapiro p-value = {sample_glitch["shapiro_pvalue"]}\nGPS Time = {sample_glitch["GPStime"]}', 
               horizontalalignment='left', 
               verticalalignment='center', 
               fontsize=14, 
               bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=1'))
    _plt.show()

def get_section_statistics(data: _pd.DataFrame, stat_test: str="Shapiro", section_size_seconds: float=1) -> list:
    '''
    A function to calculate one of the following:
    - Shapiro-Wilks Test p-values
    - Kolmogorov-Smirnov Test p-value
    - Anderson-Darling Statistics
    
    for sections of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - **data:** A **single row** of glitch information. Must contain ['t', 'y']
    - **stat_test:** The test being performed on the sections (values=["Shapiro", "KS", "Anderson"]). Default="Shapiro".
    - **section_size_seconds:** The number of sections (in seconds) being studied. The accepted values range from 0 (exclusive) to 1 with a maximum precision of 4. Default=1 second.

    Display:
    A plot of
    - The glitch sample timeseries with sections highlighted to show the concerned statistics for each section.
    - A Q-Q plot of the whole sample

    Output:
      - **section_statistics:** A list of test results in relation to each of the sections of the dataset.
    '''

    section_size_seconds = round(section_size_seconds, 5)
    
    # Obtain sample timeframe in seconds and get section size
    if section_size_seconds <= 1 and section_size_seconds > 0:
        section_size = int(_math.floor(len(data['y']) * section_size_seconds))
    else:
        section_size = len(data['y'])
    # section_size = len(data['y']) // sections
    section_info = []
    section_statistic = {}

    print(f"{stat_test} Statistics")
    print("====================")

    for i in range(0, len(data['y']+1), section_size):
        y = data['y'][i:i+section_size]
        t = _np.array(data['t'])[i:i+section_size]
        if len(y) > 0:
            if stat_test == "Shapiro":
                section_statistic = _stats.shapiro(y)._asdict()
                text = f"p={section_statistic['pvalue']:.3f}"
            elif stat_test == "KS":
                section_statistic = _stats.ks_1samp(y,_stats.norm.cdf)._asdict()
                text = f"p={section_statistic['pvalue']:.3f}"
            elif stat_test == "Anderson":
                section_statistic = _stats.anderson(y, dist='norm')._asdict()
            
            if not _np.isnan(section_statistic['statistic']):
                section_info.append({"y":y, "t":t, "section_statistic":section_statistic})

    return section_info


def display_section_statistics(data: _pd.DataFrame, stat_test: str="Shapiro", section_size_seconds: float=1) -> None:
    '''
    A funtion to display one of the following:
    - Shapiro-Wilks Test p-values
    - Kolmogorov-Smirnov Test p-value
    - Anderson-Darling Statistics
    
    of sections of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - **data:** A **single row** of glitch information. Must contain ['t', 'y', 'shapiro_pvalue']
    - **stat_test:** The test being performed on the sections (values=["Shapiro", "KS", "Anderson"]). Default="Shapiro".
    - **sections:** The number of sections being studied. Default=1.

    Display:
    A plot of
    - The glitch sample timeseries with sections highlighted to show the concerned statistics for each section.
    - A Q-Q plot of the whole sample
    - Sample Information

    '''

    infotext = ""
    section_stats = get_section_statistics(data, stat_test,section_size_seconds)

    fig, ax = _plt.subplots(3, 1, figsize=(12,12))
    _plt.suptitle(f"{stat_test} Test Statistics for section size={section_size_seconds}")
    ax[0].plot(data['t'], data['y'])

    for i, section in enumerate(section_stats):
        if len(section['y']) > 0:
            if stat_test == "Shapiro" or stat_test == "KS":
                text = f"p={section['section_statistic']['pvalue']:.3f}"
                print(section['section_statistic']['pvalue'])
            elif stat_test == "Anderson":
                if not _math.isnan(section['section_statistic']['statistic']):
                    text = f"stat={section['section_statistic']['statistic']:.3f}"
                    print(f"Section {i+1}: \nAD Statistic= {section['section_statistic']['statistic']}\nCritical Values={section['section_statistic']['critical_values']}")
            if not _np.isnan(section['section_statistic']['statistic']):
                filled_area = ax[0].fill_between(section['t'], min(section['y']), max(section['y']), alpha=0.5)
                (x0, y0), (x1, y1) = filled_area.get_paths()[0].get_extents().get_points()
                ax[0].text((x0 + x1) / 2, y1+8, f'{text}', ha='center', va='center', fontsize=8, color='black')
    
    if stat_test == "Shapiro":
        infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nKurtosis: {data['kurtosis']}\nSkew: {data['skew']}\nShapiro p-value = {data["shapiro_pvalue"]}'
    elif stat_test == "KS":
        infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nKurtosis: {data['kurtosis']}\nSkew: {data['skew']}\nKS p-value = {_stats.ks_1samp(data["y"],_stats.norm.cdf).pvalue}'
    elif stat_test == "Anderson":
        ad_stat = _stats.anderson(data["y"], dist='norm')
        infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nKurtosis: {data['kurtosis']}\nSkew: {data['skew']}\nAD Statistic = {ad_stat.statistic}\nCritical Values={ad_stat.critical_values}\nSignificance Level={ad_stat.significance_level}'
    
    _stats.probplot(data["y"], dist="norm", plot=ax[1])

    ax[2].axis('off')
    ax[2].text(0.35, 0.5, infotext, 
            horizontalalignment='left', 
            verticalalignment='center', 
            fontsize=14, 
            bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=1'))