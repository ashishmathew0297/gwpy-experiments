import math as _math
import pycbc as _pycbc
import numpy as _np
import warnings as _warnings
import pandas as _pd
from scipy import stats as _stats
import matplotlib.pyplot as _plt
from gwpy.timeseries import TimeSeries as _TimeSeries
from matplotlib.ticker import ScalarFormatter

_warnings.filterwarnings('ignore')


def fetch_glitch_data(data: _pd.DataFrame, srate: int=4096, tw: int=3, ifo: str='L1', begin: int=0, end: int=50) -> _pd.DataFrame:
    '''
    Fetches glitch samples from the TimeSeries API using a Pandas dataframe of the IFO runs dataset

    Inputs:
    - `data`: Pandas dataframe of glitch data
    - `srate`: The sampling rate. Default= 4096
    - `tw`: Time window to be taken into consideration around the glitch. The final sample returned will have 2.5 seconds removed from either side.
            Default = 3 seconds 
    - `ifo`: The interferometer being studied. Default=L1 (LIGO Livingston Observatory)
    - `begin`: Starting index. Default=0
    - `end`: End index. Default=50

    Output:
    - **data_df:** Dataframe containing the following
        - 'GPStime': Global Positioning System Time of the glitch
        - 'duration': Total duration of the glitch
        - 'noise': pycbc data of the unwhitened glitch
        - 'y': Amplitude values of the whitened glitch timeseries
        - 't': Time values of the whitened glitch timeseries,
        - 'q_transform': Q-transform of the whole glitch sample (1 second removed at either end to account for border effects)
        - 'shapiro_pvalue': Shapiro p-value of the sample amplitudes
        - 'ks_pvalue': Kolmogorov-Smirnov p-value of the sample amplitudes
        - 'ad_statistic': Anderson-Darling statistic
        - 'ad_critical_values': Critical values for the Anderson Darling statistic
        - 'ad_significance_level': Significance level for the Anderson Darling statistic
        - 'kurtosis': Kurtosis of the glitch amplitude values
        - 'skew': Skew of the glitch amplitude values
    '''
    data = data[~data.duplicated(subset=['GPStime'], keep='first')]

    data_readings = []

    # Select information based on begin and end indexes
    g_stars = data['GPStime'].iloc[begin:end]
    durations = data['duration'].iloc[begin:end].to_list()

    for i, g_star in enumerate(g_stars):

        # Fetch noise data from the LIGO GWOSC
        noise = _TimeSeries.fetch_open_data(ifo, g_star - tw ,  g_star + tw, sample_rate=srate)
        noise = noise.to_pycbc()

        # whiten the noise data
        white_noise, psd = noise.whiten(len(noise) / (2 * srate),
                                        len(noise)/( 4 * srate),
                                        remove_corrupted = False,
                                        return_psd = True)
        
        # Crop 1s at each side to avoid border effects
        white_noise = white_noise[int(srate * 1):-int(srate * 1)]
        noise = noise[int(srate * 1):-int(srate * 1)]

        # Creating q-transforms of the data for visualization
        data = _TimeSeries(white_noise, sample_rate = srate)
        q_scan = data.q_transform(qrange=[4,64], frange=[10, 2048],
                                tres=0.002, fres=0.5, whiten=False)
        
        # Localizing the glitch into a 1s interval
        t = data.times[int(srate * 1.5):-int(srate * 1.5)]
        y = data.value[int(srate * 1.5):-int(srate * 1.5)]
        noise = noise[int(srate * 1.5):-int(srate * 1.5)]

        ad_statistic = _stats.anderson(y, dist='norm')
        data_readings.append(
            (g_star,durations[i],
             noise,
             y,
             t,
             q_scan,
             _stats.shapiro(y).pvalue,
             _stats.ks_1samp(y,_stats.norm.cdf).pvalue,
             ad_statistic.statistic,
             ad_statistic.critical_values,
             ad_statistic.significance_level,
             _stats.kurtosis(y, fisher=False),
             _stats.skew(y)
             ))

    data_df = _pd.DataFrame(data_readings, columns=['GPStime', 'duration', 'noise', 'y', 't', 'q_transform', 'shapiro_pvalue', 'ks_pvalue', 'ad_statistic', 'ad_critical_values', 'ad_significance_level', 'kurtosis', 'skew'])
    
    return data_df

def shapiro_pvalue_histogram(data_df: _pd.DataFrame) -> None:
    '''
    A function to plot a histogram of the shapiro p-values from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `data_df`: The whole, or a section of the input dataframe. Must contain ['shapiro_pvalue']

    Display:
    A histogram of the Shapiro test p-values for the glitch samples 
    '''
    _plt.hist(data_df['shapiro_pvalue'], bins=40)
    # _plt.xscale('log')
    _plt.xlabel('Shapiro p-value')
    _plt.ylabel('Frequency')
    _plt.xticks(list(_np.arange(data_df['shapiro_pvalue'].min(), data_df['shapiro_pvalue'].max()+0.01, 0.01)), fontsize=8, rotation=90)
    # _plt.xticks(_np.arange(0, 0.04*tw, 0.01), fontsize=8)
    # _plt.xticks(list(_plt.xticks()[0]) + [0.05])
    _plt.title('Histogram of Shapiro p-values')
    _plt.grid(True)
    _plt.show()
    print(f"Number of Shapiro p-values above 0.05: {(data_df['shapiro_pvalue'] > 0.05).sum()}")
    print(f"Max Shapiro p-value: {data_df['shapiro_pvalue'].max()}")
    print(f"Min Shapiro p-value: {data_df['shapiro_pvalue'].min()}")

def display_glitch_plots(data: _pd.DataFrame, glitch_index: int) -> None:
    '''
    A function to display a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `data`: A single row of the input dataframe. Must contain ['t', 'y', 'noise', 'q_transform'].

    Display:
    A plot of the whitened glitch, the unwhitened glitch, and the q-transform of the glitch
    '''
    fig, ax = _plt.subplots(1,3, figsize=(24, 6))
    ax[0].plot(data['t'].iloc[glitch_index], data['y'].iloc[glitch_index])
    ax[0].set_xlabel("Time (s)")
    ax[0].set_ylabel("Amplitude")
    ax[0].legend()

    ax[1].plot(data['t'].iloc[glitch_index],data["noise"].iloc[glitch_index])
    ax[2].set_xlabel("Time (s)")
    ax[1].set_ylabel("Amplitude")
    ax[1].legend()

    ax[2].imshow(data['q_transform'].iloc[glitch_index])
    ax[2].set_yscale('log', base=2)
    ax[2].set_xscale('linear')
    ax[2].set_ylabel('Frequency (Hz)')
    ax[2].set_xlabel('Time (s)')
    ax[2].images[0].set_clim(0, 25.5)
    fig.colorbar(ax[2].images[0], ax=ax[2], label='Normalized energy', orientation='vertical', fraction=0.046, pad=0.04)

    _plt.show()

# def display_section_shapiro(data: _pd.DataFrame, section_count: int=9) -> list:
#     '''
#     A function to display the Shapiro p-values of sections of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

#     Input:
#     - `data`: A **single row** of the input dataframe. Must contain ['t', 'y', 'shapiro_pvalue'].
#     - `section_count`: The number of sections taken into consideration. Default=9.

#     Display:
#     A plot of the glitch sample timeseries with sections highlighted to show the  
#     '''
#     section_size = len(data['t'])//section_count
#     section_p_values = []
#     list_sections = []
#     print("Shapiro p-values")
#     print("====================")
#     print(f"Sample p-value:{data['shapiro_pvalue']}")

#     fig, ax = _plt.subplots(2,1, figsize=(14,7), dpi=200)
#     _plt.suptitle(f"Shapiro Test P-values for {section_count} sections. Section size={section_size}")
#     ax[0].plot(data['t'], data['y'])

#     for i in range(0,len(data['y'])+1,section_size):
#         x = data['y'][i:i+section_size]
#         t = _np.array(data['t'])[i:i+section_size]
#         list_sections.append(x)
#         if len(x) > 0:
#             section_p_values.append(_stats.shapiro(x).pvalue)
#             filled_area = ax[0].fill_between(t, min(x), max(x), alpha=0.5)
#             (x0, y0), (x1, y1) = filled_area.get_paths()[0].get_extents().get_points()
#             if not _np.isnan(_stats.shapiro(x).pvalue):
#                 print(_stats.shapiro(x).pvalue)
#                 ax[0].text((x0 + x1) / 2, y1+8, f'p={_stats.shapiro(x).pvalue:.3f}', ha='center', va='center', fontsize=8, color='black')
    
#     ax[1].axis('off')
#     ax[1].text(0.325,
#                0.6,
#                f'Shapiro p-value = {data["shapiro_pvalue"]}\nGPS Time = {data["GPStime"]}', 
#                horizontalalignment='left', 
#                verticalalignment='center', 
#                fontsize=14, 
#                bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=1'))
    
#     _plt.show()
    
#     return list_sections

def display_probability_plot(sample_glitch: _pd.DataFrame) -> None:
    '''
    A function to display the Q-Q/probability plot of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - `sample_glitch`: A **single row** of the input dataframe. Must contain ['GPStime', 'y', 'shapiro_pvalue'].

    Display:
    A plot of the glitch sample timeseries with sections highlighted to show the  
    '''
    fig,ax = _plt.subplots(1,2, figsize=(12,5))
    _stats.probplot(sample_glitch["y"], dist="norm", plot=ax[0])
    ax[1].axis("off")
    ax[1].text(0.1, 0.5, f'Shapiro p-value = {sample_glitch["shapiro_pvalue"]:.10f}\nGPS Time = {sample_glitch["GPStime"]}', 
               horizontalalignment='left', 
               verticalalignment='center', 
               fontsize=14, 
               bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=1'))
    _plt.show()

def get_section_statistics(data: _pd.DataFrame, stat_test: str="Shapiro", section_size_seconds: float=1, display_plots: bool=True) -> list:
    '''
    A function to calculate one of the following:
    - Shapiro-Wilks Test p-values
    - Kolmogorov-Smirnov Test p-value
    - Anderson-Darling Statistics
    
    of sections of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - **data:** A **single row** of glitch information. Must contain ['t', 'y', 'shapiro_pvalue']
    - **stat_test:** The test being performed on the sections (values=["Shapiro", "KS", "Anderson"]). Default="Shapiro".
    - **section_size_seconds:** The number of sections (in seconds) being studied. The accepted values range from 0 (exclusive) to 1 with a maximum precision of 4. Default=1 second.

    Display:
    A plot of
    - The glitch sample timeseries with sections highlighted to show the concerned statistics for each section.
    - A Q-Q plot of the whole sample

    Output:
      - **section_statistics:** A list of test results in relation to each of the sections of the dataset.
    '''

    section_size_seconds = round(section_size_seconds, 4)
    
    # Obtain sample timeframe in seconds and get section size
    if section_size_seconds <= 1 and section_size_seconds > 0:
        section_size = int(_math.floor(len(data['y']) * section_size_seconds))
    else:
        section_size = len(data['y'])
    # section_size = len(data['y']) // sections
    section_statistics = []
    section_statistic = {}
    infotext=""
    skew_kurtosis = f"Kurtosis: {data['kurtosis']}\nSkew: {data['skew']}"

    print(f"{stat_test} Statistics")
    print("====================")
    # print(_stats.ks_1samp(data["y"],_stats.norm.cdf))
    if display_plots:
        fig, ax = _plt.subplots(3, 1, figsize=(12,12))
        _plt.suptitle(f"{stat_test} Test Statistics for {section_size_seconds} second sections. Section size={section_size}")
        ax[0].plot(data['t'], data['y'])

    for count,i in enumerate(range(0, len(data['y']+1), section_size)):
        y = data['y'][i:i+section_size]
        t = _np.array(data['t'])[i:i+section_size]
        if len(y) > 0:
            if stat_test == "Shapiro":
                section_statistic = _stats.shapiro(y)
                text = f"p={section_statistic.pvalue:.3f}"
                print(section_statistic.pvalue)
            elif stat_test == "KS":
                section_statistic = _stats.ks_1samp(y,_stats.norm.cdf)
                text = f"p={section_statistic.pvalue:.3f}"
                print(section_statistic.pvalue)
            elif stat_test == "Anderson":
                section_statistic = _stats.anderson(y, dist='norm')
                if not _math.isnan(section_statistic.statistic):
                    text = f"statistic={section_statistic.statistic:.3f}"
                    print(f"Section {count+1}: \nAD Statistic= {section_statistic.statistic}\nCritical Values={section_statistic.critical_values}")

            section_statistics.append(section_statistic)
            
            if not _np.isnan(section_statistic.statistic) and display_plots:
                filled_area = ax[0].fill_between(t, min(y), max(y), alpha=0.5)
                (x0, y0), (x1, y1) = filled_area.get_paths()[0].get_extents().get_points()
                ax[0].text((x0 + x1) / 2, y1+8, f'{text}', ha='center', va='center', fontsize=8, color='black')
    
    if display_plots:
        _stats.probplot(data["y"], dist="norm", plot=ax[1])

        if stat_test == "Shapiro":
            infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nShapiro p-value = {data["shapiro_pvalue"]}\n'
        elif stat_test == "KS":
            infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nKS p-value = {_stats.ks_1samp(data["y"],_stats.norm.cdf).pvalue}\n'
        elif stat_test == "Anderson":
            ad_stat = _stats.anderson(data["y"], dist='norm')
            infotext = f'GPS Time = {data["GPStime"]}\nDuration = {data["duration"]}\nAD Statistic = {ad_stat.statistic}\nCritical Values={ad_stat.critical_values}\nSignificance Level={ad_stat.significance_level}\n'

        ax[2].axis('off')
        ax[2].text(0.35, 0.5, infotext+skew_kurtosis, 
                horizontalalignment='left', 
                verticalalignment='center', 
                fontsize=14, 
                bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=1'))

    return section_statistics


def display_section_statistics(data: _pd.DataFrame, stat_test: str="Shapiro", sections: float=1) -> None:
    '''
    A funtion to display one of the following:
    - Shapiro-Wilks Test p-values
    - Kolmogorov-Smirnov Test p-value
    - Anderson-Darling Statistics
    
    of sections of a sample glitch from the input dataframe generated by `fetch_glitch_data()`

    Input:
    - **data:** A **single row** of glitch information. Must contain ['t', 'y', 'shapiro_pvalue']
    - **stat_test:** The test being performed on the sections (values=["Shapiro", "KS", "Anderson"]). Default="Shapiro".
    - **sections:** The number of sections being studied. Default=1.

    Display:
    A plot of
    - The glitch sample timeseries with sections highlighted to show the concerned statistics for each section.
    - A Q-Q plot of the whole sample
    - Sample Information

    '''

    fig, ax = _plt.subplots(3, 1, figsize=(12,12))
    _plt.suptitle(f"{stat_test} Test Statistics for {sections} sections. Section size={section_size}")
    ax[0].plot(data['t'], data['y'])

    get_section_statistics(data, stat_test,sections)